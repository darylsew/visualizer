<!DOCTYPE html>
<style>
    canvas {
        width: 100%;
        height:100%;
        border-style: solid;
    }
</style>
<body>
    <script src="../static/three.min.js"></script>
    <script>
        var camera, scene, renderer;
        var scene_WID, scene_HT;
        var grid_WID, grid_HT;
        var planeGeometry, planeMaterial, plane;
        var spotlight;
        var cubes, cubeGeometry, materials;
        var centroids, frequencies, volumes;
        var curated_centroids, curated_frequencies, curated_volumes;

        init();
        curate();

        function init() {
            scene_WID = window.innerWidth;
            scene_HT = window.innerHeight;
            /* Camera */
            camera = new THREE.PerspectiveCamera(75, scene_WID / scene_HT, 0.1, 1000);
            camera.position.z = 9;

            /* Background */
            planeGeometry = new THREE.PlaneGeometry(450, 450, 0, 0);
            planeMaterial = new THREE.MeshPhongMaterial({
                color: 0xa0a0a0
            });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);

            /* Cube Grid */
            grid_WID = 15; //CHANGE THESE TO EDIT SIZE OF GRID
            grid_HT = 10; //may have to alter x and y below
            //as well as camera.position.z
            cubes = new Array(grid_WID);
            for (var i = 0; i < grid_WID; i++) {
                cubes[i] = new Array(grid_HT);
            }
            materials = new Array(grid_WID * grid_HT);
            for (var i = 0; i < grid_WID * grid_HT; i++) {
                materials[i] = new THREE.MeshPhongMaterial({
                    color: 0xc0c0c0
                });
            }
            cubeGeometry = new THREE.CubeGeometry(0.5, 0.5, 0.5);
            var x = -7;
            var mat = 0;
            for (var i = 0; i < grid_WID; i++) {
                var y = -4;
                for (var j = 0; j < grid_HT; j++) {
                    cubes[i][j] = new THREE.Mesh(cubeGeometry, materials[mat]);
                    cubes[i][j].position.x = x;
                    cubes[i][j].position.y = y;
                    y++;
                    mat++;
                }
                x++;
            }

            /* Lights */
            light = new THREE.SpotLight(0xffffff);
	    light_L = new THREE.SpotLight(0x404040);

            /* Additions and positioning */
            scene = new THREE.Scene();
            scene.add(plane);
            plane.position.z = -1;
            for (var i = 0; i < cubes.length; i++) {
                for (var j = 0; j < cubes[i].length; j++) {
                    scene.add(cubes[i][j]);
                }
            }
            scene.add(light);
            scene.add(light_L);
            light_L.position.x = -25;
            light_L.position.z = 15;
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(scene_WID, scene_HT);
            document.body.appendChild(renderer.domElement);
        }

        function curate() {
            centroids = {{centroids}};
            curated_centroids = new Array(centroids.length * 2);
            for (var i = 0; i < curated_centroids.length; i++) { // convert to 60fps
                curated_centroids[i] = centroids[i - i % 2];
                curated_centroids[i] = curated_centroids[i];
            }

            frequencies = {{frequencies}};
            curated_frequencies = new Array(frequencies.length * 2);
            for (var i = 0; i < frequencies.length; i++) {
                var sum = 0;
                for (var j = 0; j < frequencies[i].length; j++) {
                    sum += frequencies[i][j];
                }
                curated_frequencies[2 * i] = sum / frequencies[i].length;
            }
            for (var i = 0; i < curated_frequencies.length; i++) {
                curated_frequencies[i] = curated_frequencies[i - i % 2];
            }
            for (var i = 0; i < curated_frequencies.length; i++) {
                curated_frequencies[i] = Math.floor(
                curated_frequencies[i] * grid_WID - 1);
            }

            volumes = {{volumes}};
            curated_volumes = new Array(volumes.length * 2);
            for (var i = 0; i < curated_volumes.length; i++) {
                curated_volumes[i] = volumes[i - i % 2];
                curated_volumes[i] = Math.floor(curated_volumes[i] * (grid_HT - 1));
            }
        }


        function light_column(freq, vol) {
            for (var i = 0; i <= vol; i++) {
                if (i >= 0.7 * grid_HT) {
                    cubes[freq][i].material.color.setHex(0xff0000);
                } else {
                    cubes[freq][i].material.color.setHex(0x0000ff);
                }
            }
            setTimeout(function () {
                for (var i = 0; i < grid_HT; i++) {
                    cubes[freq][i].material.color.setHex(0xc0c0c0);
                }
            }, 400);
        }

        function light_region(freq, vol) {
            light_column(freq, vol);
            if (vol >= 3) {
                if (freq > 0) {
                    light_column(freq - 1, vol - 2);
                }
                if (freq < grid_WID - 1) {
                    light_column(freq + 1, vol - 2);
                }
            }
            if (vol >= 5) {
                if (freq > 1) {
                    light_column(freq - 2, vol - 4);
                }
                if (freq < grid_WID - 2) {
                    light_column(freq + 2, vol - 4);
                }
            }
        }


        var index = 0;

        function render() {
            requestAnimationFrame(render);
            renderer.render(scene, camera);
            camera.position.x = 4 * Math.cos(index / 250);
            camera.position.y = 2 * Math.sin(index / 250);
            light.position.z = 30 + 60 * curated_centroids[index];
            camera.lookAt(new THREE.Vector3(0, 0, 0));
            light_region(curated_frequencies[index], curated_volumes[index]);

            index = (index + 1) % volumes.length;
        }

        render();
    </script>
</body>

</html>
